#include <math.h>
#include "cuda_defs.h"

#ifndef MMVector_Math
#define MMVector_Math


template<typename T, int from>
struct COPY {
  __host__ __device__ static void APPLY(const T* source, T* destination) {
    destination[from] = source[from];
    COPY<T, from-1>::APPLY(source, destination);
  }
};

// terminal case
template<typename T>
struct COPY<T, 0> {
  __host__ __device__ static void APPLY(const T* source, T* destination) {
    destination[0] = source[0];
  }
};


template<typename T, int M>
class VecNd {
  T buffer[M];
public:
  __host__ __device__ inline VecNd(){}
  
  __host__ __device__ inline VecNd(T val){
    for (int i = 0; i < M; i++){
	buffer[i] = val;
    }
  }

  __host__ __device__ inline VecNd(T* memBuff){
    for (int i = 0; i < M; i++){
	buffer[i] = memBuff[i];
    }
  }

  __host__ __device__ inline T& operator[](int i){
    return buffer[i];
  }
  /*
  __host__ __device__ inline VecNd(const VecNd<T, M> &m1){
    for (int i = 0; i < M; i++){
      buffer[i] = m1.buffer[i];
    }
  }
  */
  __host__ __device__ inline VecNd<T, M> operator*(const VecNd<T, M>& v1){
    VecNd<T, M> vec2;
    for (int i = 0; i < M; i++){
      vec2[i] = buffer[i] * v1.buffer[i];
    }
    return vec2;
  }
  __host__ __device__ inline VecNd<T, M>& operator=(const VecNd<T, M>& m1){
    COPY<T, M>::APPLY(m1.buffer, buffer);
    return *this;
  }

  __host__ __device__ inline VecNd<T, M>& operator=(const T val){
    for (int i = 0; i < M; i++)
      buffer[i] = val;
    return *this;
  }

  __host__ __device__ inline VecNd<T, M>& operator+=(const VecNd<T, M>& m1){
    for (int i = 0; i < M; i++)
      buffer[i] += m1.buffer[i];
    return *this;
  }

  __host__ __device__ inline VecNd<T, M>& operator-=(const VecNd<T, M>& m1){
    for (int i = 0; i < M; i++)
      buffer[i] -= m1.buffer[i];
    return *this;
  }

  __host__ __device__ inline VecNd<T, M>& operator+=(const T& val){
    for (int i = 0; i < M; i++)
      buffer[i] += val;
    return *this;
  }
};

template<typename T, int M>
__host__ __device__ inline VecNd<T, M>  operator*(T x, VecNd<T, M>&  v){
  VecNd<T, M> v_out;
  for (int i = 0; i < M; i++){
    v_out[i] = v[i] * x;
  }
  return v_out;
}

template<typename T, int M>
__host__ __device__ inline VecNd<T, M>  operator*(VecNd<T, M>&  v, T x){
  VecNd<T, M> v_out;
  for (int i = 0; i < M; i++){
    v_out[i] = v[i] * x;
  }
  return v_out;
}


template<typename T, int N>
__host__ __device__ inline T mag(VecNd<T, N>& m1){
  return sqrt(dot(m1, m1));
}


template<typename T, int N>
__host__ __device__ inline T dot(VecNd<T, N>& m1, VecNd<T, N>& m2){
  T val = 0;
  for (int i = 0; i < N; i++){
    val += m1[i] * m2[i];
  }
  return val;
}


template<typename T, int M>
__host__ __device__ inline VecNd<T, M>  operator+(VecNd<T, M>& m1, VecNd<T, M>& m2){
  VecNd<T, M> mat_out;
  for (int i = 0; i < M; i++){ 
    mat_out[i] = m1[i] + m2[i];
  }
  return mat_out;
}

template<typename T, int M>
__host__ __device__ inline VecNd<T, M>  operator-(VecNd<T, M>& m1, VecNd<T, M>& m2){
  VecNd<T, M> mat_out;
  for (int i = 0; i < M; i++){ 
      mat_out[i] = m1[i] - m2[i];
  }
  return mat_out;
}

template<typename T>
__host__ __device__ inline VecNd<T, 3>  cross(VecNd<T, 3>& m1, VecNd<T, 3>& m2){
  VecNd<T, 3> mat_out;
  mat_out[0] = m1[1] * m2[2] - m1[2] * m2[1];
  mat_out[1] = m1[2] * m2[0] - m1[0] * m2[2];
  mat_out[2] = m1[0] * m2[1] - m1[1] * m2[0];
  return mat_out;
}

typedef VecNd<Real_t, 4> Vec4;
typedef VecNd<Real_t, 3> Vec3;
typedef VecNd<Real_t, 2> Vec2;

#endif 

